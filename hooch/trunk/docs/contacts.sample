#
# Sample Turner/Hooch address book
#
# $Id$
#

#
# Defaults
#
defaults {
	#
	# No name or address setting, as that would not be logical.
	# Probably it is wise to generalise and allow it anyway.  Let's
	# provide the user enough rope to hang himself with, ok? ;)
	#
	picture = ~/pics/questionmark.png	# No photo
	pgp {
		# No key_id, would be stupid to have one. (aka key_id = empty;)
		sign = yes;
		encrypt = yes;		# Encryption to an `empty' key id just
					# sends an unencrypted mail anyway.
	}
}

#
# Multiple identities per contact are possible, by defining id-blocks for a contact.
#
contact homer {
	# XXX Internally these are just the `primary' id.
	address = "homer@simpsons.net";
	pgp.key_id = empty;

	id work {
		address = "homer@powerplant.net";
		pgp.key_id = "0xBABE2ADE5BED";

		# XXX: Consider this
		info { ... }
		behaviour { ... }	# <-- These things should be allowed
					#     to be defined in the `defaults'
					#     block and in `groups' blocks
		# I'm rather against doing this in the syntax.  It is
		# much nicer to have internal rules which fields may or
		# may not appear in an id / contact / group.
		# If a user enters something in a `defaults' section, he
		# will simply get an error: `xxx is only allowed as
		# contact information' (or something).  It is not much
		# cleaner to have the info { .. } behaviour { .. }
		# keywords, although it may appear to be cleaner at first
		# sight.  In the end, if a user puts something that belongs
		# in info under behaviour (or elsewhere), he will get the
		# same (rephrased) error (`xx is only allowed in info blocks')..
		#
		# It is probably best to keep the checks internal to the
		# programs, and make clear in the documentation where things
		# may or may not be.
		#
		# If it helps to resolve cognitive dissonance, see defaults
		# and contact classes that inherit from a common `behaviour'
		# class, which contacts extend to include some info fields.
	}
}

#
# Every declaration should either be of the form x { stuff here } or x = foo;
# A block declaration like x { } should never be followed by a semi-colon.
#

#
# Now we can access homer's work address with `homer:work'
# Specifying a contact's specific e-mail address in a group can be also done easily now:
#
group employees { members = homer:work, smithers; }

#
# We might even get rid of the annoying notation that links addresses to pgp
# keys by grouping them together under a different identity:
#
contact homer {
	address = "homer@simpsons.net";			# Main address
	pgp.key_id = 0xabcdef;				# With PGP key
	id work {
		address = "homer@powerplant.net";	# Work address
		#
		# We need to explicitly set this to empty, because
		# the settings from the main ID are cascaded over into
		# the id things.
		#
		pgp.key_id = empty;			# empty sets the item
							# to be undefined
	}
}

#
# The user's e-mail addresses are simply recorded with a special
# contact:
#
contact self {			# Or `contact me'?  Or `contact this'? :P
	name = "Joe User";
	address = "1337hoochdude@aol.com";

	id work {
		address = "juser@dulljob.com";
	}
}

##########
# Groups #
##########

# Groups are defined like this:
group parents {
	members = marge, homer;
	option1 = y;
	option2 = foo;
}

#
# If after reading and parsing all config files there are still contacts in a
# `members' field of a group which do not exist, we get an error.  It is legal
# to forward-reference the contacts in a group.
#

#
# Note that there may not be a contact with the same name as a group, or else
# we get an error.  This is the desired effect, since the user can now type a
# mail, and on the `To:' line type the name of either a group or a contact and
# get an unambiguous expansion.
#

#
# We allow the exact same options for groups as for contacts, to provide
# group-wide defaults for all contacts.  When addressing the group, the
# group settings will have effect, but when addressing the contact directly,
# the contact's settings have effect.
#

#
# Subsystems/extensions can be handled with ease.  They simply register which
# lines (under which blocks (so register "pgp.key_id", "pgp.sign" etc) they
# understand and the type of these fields.  Perhaps even new toplevel blocks
# (say `gui' or something)
# This way we can error immediately on keywords we don't understand.
#
contact burns {
	name = "Mr. Burns";
	address = "burns@powerplant.net";

	# Picture plugin/GUI which optionally shows photos of your contacts
	picture = "~/pics/ugly_mug.png";

	# More elaborate plugins can be passed a structure with many fields
	pgp {
		key_id = "0x1029384756";# Number or string? (Hex! what if no 0x)
		encrypt = yes;		# bool.  true/false also accepted
		sign = yes;
	}

	#
	# One can refer to structures or contacts with dot notation,
	# for example suppose we only want to specify a key id, and rely
	# on sane defaults for the rest of the PGP subsystem:
	#
	pgp.key_id = "1029384756";

	# Of course, this idea can (and should, for intuity/consistency
	# reasons) be extended.  For example, we could use burns.address
	# if we want to refer to the address field of the contact or group
	# called `burns' in any other place of the program.  (and so on)
}

# Quick example of mailing lists
contact daily {
	name = "The Springfield Daily";
	address = "daily@springfield.net";

	#
	# Specifying `list = yes' means that the user can do a `list reply'
	# to the list instead of to the person.  Of course, our settings
	# might include something which could optionally even make this
	# the default for a reply to a mailing list msg.
	# Specifying `list = yes' also (optionally?) transforms the default
	# `to' display to the mailing list address instead of your address.
	# Also, mail-followup-to field is set to the list when replying.
	#
	# Optionally, one can define other list-specific settings as well,
	#  in new plugins etc.
	#
	# Threaded view of a mailbox is NOT enabled with this setting.
	#
	list = yes;				# Defaults to `no'
}
