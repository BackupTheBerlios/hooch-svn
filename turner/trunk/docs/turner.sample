#
# Sample Turner script
#
# $Id$
#
# <sjamaan>
# I removed old <sjamaan> and <nvie> keywords and introduced new <sjamaan>'s
#  for the comments I just added.
#

#
# Q: We only match on mail headers, right? Or mail body content as well?
#
# A: Hmm, I think it should be possible to grep for words in an e-mail, but
#     let's defer this, since we are still considering a way to do things
#     depending on program exit code.  We could check for success from using
#     grep on the e-mail body.
#

#
# First we should specify where contacts are located
#
# Q: Perhaps in a turner { } block?  Although that actually should imply
# settings for Turner, but these need to be made in .turnerrc.
#
# A: I think that's a bad idea for two reasons:
# 1 - The file will get very indented without good reason, since 99% or so
#      of it will be inside the { } block.
# 2 - We don't have the contacts in some contacts { } block either, do we?
#

#
# NOTE:
# We should make a distinction between incoming and outgoing mails from the
# user. This can be done with a switch to turner, or perhaps calling the
# binary a different name or something.  It doesn't matter, as long as turner
# knows in which mode it is.
#

#
# We really need a way to invoke external programs (optionally piping the mail
# to the program, but an empty stdin must be possible too), and we also must
# find a way to /optionally/ use that output as the new mail (filtering).
#
# XXX: Perhaps we even need to do things based on exit code??
#
# XXX: We should also consider how we implement groups, once we're done with
#      this.
#
# XXX: In the rule-block below, where do we allow for send and recv mode
#      control options?
#
# A: Anywhere?  I don't see a reason to restrict the send {} and recv {}
#     block position.  Even AROUND a rule (meaning the rule is not even
#     considered in the mode), around a match, inside a match(!),
#     around a `perform' block(?).  This last should imply we can
#     have two `perform' blocks inside a rule.  This would normally
#     not be allowed, but since the program does not consider things
#     wrapped in a block of the other mode, it is possible.
#
#    Since we would rather obviously also allow send/recv checks inside
#     a `perform' (I hate this name already) block, we might consider
#     not allowing them around perform blocks, but I personally think
#     that would destroy some consistency.
#
#    One of the nicer things is that we can also allow conditional
#     option-setting.  Like so:
recv {
	maildir = "~/Mail/inbox";
	# ... other options ...
}
send {
	maildir = "~/Mail/outbox";
	# ... other options ...
}
#
# But of course, we can do this only if we actually allow turner options
#  in this rules file as well...  This might be a good reason to allow it,
#  come to think of it.  On the other hand, we could also allow send/recv
#  blocks in a separate `.turnerrc' and allow only rules in this file.
# That might be cleaner, unless there simply are only a handful of options
#  for Turner at all.  It is rather silly to have a .turnerrc contain only
#  one line ;)  (but very academical, though, since this rule file can be
#  re-used for other programs as it would contain no Turner-specific things)
#
rule {
	#
	# First, we can define some patterns that should be matched.
	# Every match-block should be matched in order to proceed with the
	# script.  (implicit AND between matches)
	#
	# A `match' is matched when any of the pattern-declarations in it are
	# matched in the input mail headers.  (implicit OR within matches)
	#
	match {
		#
		# Specify what from should contain in order to match.
		#
		# Q: How can we specify "homer:work, but no-one else"? :}
		#
		# A: The key to the answer possibly lies in a NOT operator
		#     Either that, or we should swap the AND/OR behaviour
		#
		# Another way to do it, which I definately do NOT prefer,
		#  is creating a new operator, a `unique-equals' operator:
		#
		from == homer:work;
		# 
		# or, in spirit of the `Precisely one' existential quantifier
		# in maths:
		#
		from != homer:work;
		#
		# (but this is very confusing to C programmers)
		#
		#
		from = homer:work		# Either homer's work account..
		     | marge:*			# any address of marge..
		     | "someone@else\.com";	# or a regular expression

		# The match is also valid if X-Custom is set to `foo'
		#
		# Q: Why the `header' keyword?  Isn't it enough to look for
		#     quotes?  Quotes mean the literal header, the from/to etc
		#     identifiers are declared internally.  This is also
		#     more consistent with how we make the distinction between
		#     literal e-mail addresses or symbolic ones from contacts.
		#
		header "X-Custom" = "foo";
		#
		# I'd suggest just this:
		#
		"X-Custom" = "foo";
		#
		# XXX: Are these things the same?
		# to = "foo";
		# "to" = "foo";
		# It would be nice to allow to to be mapped to `cc', `bcc' or
		# `to'.  Well, it's not important yet, we simply can define
		# what they mean when we are done with the rest of the syntax.
		#

		#
		# Q: This just slipped into my mind.  Should we allow for
		#    such "high-level" constructs?
		#
		num_addressees >= 5;
		#
		# A: I don't like it a bit, but it's way cleaner to use this
		#     than to do a regex-match on the number of @-signs in a
		#    from/to line, like I do in my .procmailrc. :-(
		#    I would really like a different notation though.
		#
		#    Something along the lines of `{3,5}*'   but the problem
		#     here is that this would allow only 3 to 5 addresses
		#     from the /contact list/... We need to be able to count
		#     just the number of addresses, including those not in
		#     the list.
		#
		# I suggest to define macro's, so we could say stuff like:
		#
		count(to) < 3;
		count(to) >= 5;
		#
		# But, I seriously make a point of it now that we need to
		# watch ourselves putting in this kind of feature creep,
		# especially because it does not share syntax with the
		# rest of the file, and we might get tremendous parsing
		# problems.
		#
		# <sjamaan>
		# The macros thing is an alright idea.  Perhaps we could
		# find something more elegant, but let's keep this in mind.
		#
	}

	match {
		# Another match that should be passed
		to = bart:*;		# Mail sent to any address of bart

		#
		# Note that the line below is invalid if the
		# allow_implicit_primary option is set to `no'
		# (which is the default, if not set):
		#
		cc = maggy;		# Invalid, user may intend maggy:*
		cc = maggy:primary;	# Valid alternative
	}
	
	#
	# Q: Psycological issue: consider this:
	#           match { to = bart:*; }
	#    What we mean by that is: the To-field *contains* any address of
	#    Bart.  Will the =-operator not false imply an equality relation,
	#    instead of a "containment"?
	#    ``Confusion is drawing near...  I can feel it.''
	#
	# <sjamaan>
	# You're right about that.  Perhaps we can revise the old notation,
	#  and use `set x "value";' instead?  That would fix it all.
	# Or, just use := for assignment, like in Pascal.  I like both methods
	#  a lot, although the first one is more `native Unix tongue', since
	#  mutt, vi, some shells etc use this notation.
	#
	# (about `act' keyword)
	# My point remains.  Overthink this.
	#
	# Agree.  But names are appealing as well.  And: if they become
	# legacy, the become terribly rancid.  (car, cdr, anyone?)  Keep an
	# open mind.  Now is the time we can easily change it.
	#
	act {
		#
		# Every command in an act-block is executed in the order they
		# are stated.  Every command is of the following form:
		cmd "command(s) in shell syntax";
		# or
		cmd 'command(s) in shell syntax';

		#
		# Possible cmd-identifiers:
		#
		# !	Execute a command, no stdin, stdout is ignored.
		# <	Execute a command, stdin is the mail, mail gets
		# 	replaced by stdout.
		# |	Execute a command, stdin is the mail, stdout ignored.
		# >	Store the mail to the given mailbox.
		#
		# Some examples:
		! "beep";		# The PATH is searched for ``beep''
		| "mail -s \"Here's a mail\"";
		< "/usr/bin/remove-pink-color-tags";
		> "incoming/kids";

		# This can be useful when dealing with commands that contain
		# quotes.  Like in many programs, you need to escape quotes
		# used in strings somehow.  Because we make no difference *at
		# all* between these two types of strings, this leaves the user
		# with the possibility of easy escaping strings.  Examples:
		| "/usr/bin/mail -s \"Here's a mail\"";
		| '/usr/bin/mail -s "Here\'s a mail"';
		| "/usr/bin/mail -s 'Here\'s a mail'";

		# XXX: RANS:
		# Mind the subtle difference in the \'s-part of the two strings
		# above!  In the first case, the ' is escaped, meaning that the
		# single quote is just passed to the shell (w/o backslash).  In
		# the latter case the \ represents a regular \, since it is not
		# directly followed by a valid special character (only " would
		# be in this case).  Therefore, the backslash is passed along
		# with the string and is necessary for the shell to be
		# interpreted correctly.
		#
		# <sjamaan>
		# Should we really do it that way? In the shell, a \ just means
		# `insert the next character, without regards to the special
		#  meaning of it'.  In C, it does the same, but while compiling
		#  we get a warning "unknown escape sequence \y".
		#
		# So I vote for the shell-way, and inserting a literal \ always
		#  with \\.  No context-sensitive behaviour, that will
		#  inevitably confuse people.
		#

		# Strings may be spread across lines, in standard C-fashion:
		! "/usr/local/bin/b"
			"e"
		    "e"
		    			   "p";
		! '/usr/bin/mail -s "Some very long subject'
			'that needs at least two lines"';

		# Because all of this is executed by the shell, it is allowed to
		# specify multiple commands in a chain:
		< "sort | head -n 50";
	}
}

#
# A simple, real-life, example
#
rule {
	match { from = krusty:*; }
	act { > '/dev/null'; }	# F*ck that damned clown!
}

rule {
	match { subject = "news"; }
	act {
		< "strip-html";	# Let the strip-html program clean the mail
		> "newsletters";
	}
}


#
# XXX: How do we indicate that a match is halting or non-halting when it is
#       matched?  Here's a possible way (which I prefer):
#
# Hmm!  I forgot about that completely.  Nice, nice, nice.  ``It's a keeper!''
# I deleted the other block, for it was very rans ;)
#
terminal rule {				# Simply an extra keyword
	match {
		from = spammers;
	}
	> "/dev/null";
}


#
# Something to consider:
# What do we do by default?  How many times would one want a match NOT
#  to terminate versus how many times one would want a match to terminate?
#
# Perhaps it is better to have a rule terminate by default unless specified
# otherwise?  Then change the keyword to something else:
#
non-terminal rule {
	match {	}			# XXX: An empty block always matches?
					# Note that a missing match { } block
					# conceptually means that the rule
					# should never match, so that's
					# something completely different.

	# <nvie>
	# I fully agree.  Maybe add some syntactic sugar for this? Like so:
	#
	# <sjamaan>
	# Good idea.  Looks better.  `always' just expands to { }.
	match always;

	# Beep on new mail
	! "beep";
}

#
# XXX: Consideration
# I guess, indeed, that terminals should be considered the default.
# However, some interesting point may be to let Turner detect it itself, i.e.
# by letting a match be terminal when it uses the '>'-operator to write to
# a mailbox.
#
# Pros:
# * Simple, elegant
# * Less typing required (and thus, less complex scripts)
#
# Cons:
# * Possible to write to one mailbox at most
# <sjamaan>
# * Confusing and not very clear when one has a long rule, or one which
#    does write on recv { } but not on send { }.
#
# Because the only con will be almost never used in practise, still it
# scratches.  Typically, you don't want such a restriction.
# Maybe... a golden midway.  A proposal:
# 1. A rule is a non-terminal one if no ">" is used.
# 2. Otherwise a rule is terminal, UNLESS you specify the non-terminal
#    keyword.
#
# Big example:

# Implicit non-terminal, since ">" is not used.
rule {
	match always;
	! "beep";
}

# Explicit non-terminal required here, if one could have friends at work :)
non-terminal rule {	
	match { from = friends:*; }
	> "friends";
}

# This rule is a terminal again
rule {
	match { from = acme:*; }
	> "acme";
}

#
# <sjamaan>
# I vote for dropping this.  Rules are always terminal, unless explicitly
#  marked `non-terminal' (or some shorter keyword instead)
#
