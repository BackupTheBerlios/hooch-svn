#
# Sample Turner script
#
# $Id$
#

#
# Q: We only match on mail headers, right?
#

# First we should specify where contacts are located
#
# Q: Perhaps in a turner { } block?  Although that actually should imply
# settings for Turner, but these need to be made in .turnerrc.
#
# A: I think that's a bad idea for two reasons:
# 1 - The file will get very indented without good reason, since 99% or so
#      of it will be inside the { } block.
# 2 - We don't have the contacts in some contacts { } block either, do we?
#

#
# This is a good idea to support, but I don't think we should focus on it now
# We should have sensible defaults anyway (search ~/.contacts, ~/.hooch/contacts
# etc)
#
contacts-file = ~/.hooch/contacts

#
# A mailbox prefix?
# Once again, we shouldn't focus on these features.  We should try to create
# a decent notation for the mail rules.  But of course, we need to support this.
#
# If we have a .turnerrc as well, this sort of stuff should go there and we
# can have only rules in this file.
#
mailbox = ~/Mail

#
# We should make a distinction between incoming and outgoing mails from the user
# This can be done with a switch to turner, or perhaps calling the binary
# a different name or something.  It doesn't matter, as long as turner knows
# in which mode it is.
#

#
# If we only have rules in this file, the `match' keyword is superfluous.
#
# If that is the case, we can define the from fields right before the braces
# like so:
#

from (bart:fun | "blah@foo.com") |
to (lisa) {
	# Execute the beep program without using the e-mail as stdin
	! "beep";

	# Pipe the e-mail to another program.  The stuff in quotes is executed
	#  by /bin/sh.
	| "(echo 'Hey, news from the kids!:'; cat)";

	# Receive mode?
	recv {
		$target = "incoming";
	}
	send {
		$target = "outgoing";
	}
	# And store the mail in incoming/guys or outgoing/guys
	> "${target}/kids"
}

to (maggy | "bar@qux.com") |
from (marge:home) {
	# Process the e-mail with a filter
	< "filter-out-pink-color-tags";
	# Store it in the `girls' mbox
	> "girls"
}

#
# But I like this notation much more (more readable).  Perhaps we
# can find a `golden midway' :P
#
# We really need a way to invoke external programs (optionally piping the mail
# to the program, but an empty stdin must be possible too), and we also must
# find a way to /optionally/ use that output as the new mail (filtering).
#
# Perhaps we even need to do things based on exit code??
#
rule {
	#
	# First, we can define some patterns that should be matched
	# Every match-block should be matched in order to proceed with the
	# script.
	#
	# A `match' is matched when any of the pattern-declarations in it are
	# matched in the input mail headers.
	#
	match {
		#
		# Specify what from should contain in order to match.
		#
		# Q: How can we specify "homer:work, but no-one else"? :}
		#
		from = homer:work		# Either homer's work account...
		     | marge:*			# any address of marge...
		     | "someone@else\.com";	# or a regular expression

		# The match is also valid if X-Custom is set to `foo'
		header "X-Custom" = "foo";

		#
		# Q: This just slipped into my mind.  Should we allow for
		#    such "high-level" constructs?
		#
		num_addressees >= 5;
	}

	match {
		# Another match that should be passed
		to = bart:*;		# Mail sent to any address of bart

		#
		# Note that the line below is invalid if the
		# allow_implicit_primary option is set to `no'
		# (which is the default, if not set):
		#
		cc = maggy;		# Invalid, user may intend maggy:*
		cc = maggy:primary;	# Valid alternative
	}

	#
	# An execute block is executed in the order it is presented so execute
	# { x y z } will execute x first, then y, then z A match may contain
	# only one execute block
	#
	# The begin block is run as the very last thing.  So settings AFTER a
	# begin block still hold inside the bagin block.
	#
	# Example: match { begin { echo "Foo!"; } from marge; } will trigger on
	# mail from marge and print `Foo'.
	#
	# XXX: The name ``begin'' is very general.  We could be much more
	# specific and call ``the animal by its name'', for example, by calling
	# it: execute, batch, perform, run, action, etc.
	#
	begin {
		#
		# I still favor the short syntax used before.  It's much more
		# in Unix-style, like the rest of our program will be.  Why use
		# the Mickey Mouse names "exec" when a simple "!" fits?
		#
		# However, torn between academics and insolent, practical
		# hacking, I like the "clear" declarative style also.
		#
		# Therefore, this is my suggestion:  We allow for an option
		# allow_short_script_cmds (``yes'' per default) that, for
		# example, allows "exec" to be written for short using the "!"
		# notation.  (Just for good ol' Unix-convenience.)
		#

		# Execute a command, no stdin, stdout is ignored.
		exec /usr/local/bin/beep
		! /usr/local/bin/beep

		# Execute a command, stdin is the mail, stdout is ignored.
		pipe /usr/bin/mail -s "..."
		< /usr/bin/mail -s "..."

		# Filter the mail through an external program, stdin is the
		# mail, the mail body is replaced by stdout
		filter /usr/bin/remove-pink-color-tags
		| /usr/bin/remove-pink-color-tags

		# Write to the mailbox
		store incoming/kids
		> incoming/kids

		# =============================================================
		#   pbex's stuff below this line
		# =============================================================

		# Stuff in an exec block is a shell script (or perhaps some
		# other program, depending on .turnerrc!!)
		exec {
			# anything the shell (or whatever interpreter
			# one chooses to invoke on exec blocks) accepts.
			/usr/local/bin/beep		# on mail arrival
		}
		# pipe blocks are like exec blocks, but stdin is open and
		# offers the e-mail.
		pipe {
			#
			# Problem: How can we make information from turner
			# available within this block?
			# Use the environment???
			#
			/usr/bin/mail -s "One of your employees received \
					  an e-mail" boss@powerplant.net
		}

		# filter blocks are exactly like pipe blocks, only everything
		# below the block uses stdout from the block as the new
		# e-mail.
		filter {
			# something that transforms the e-mail
			/usr/bin/remove-pink-color-tags
		}

		# Now, any pink color tags are gone! (we're still in the
		# begin { } block, so the order of things is important.
	}

	# =====================================================================
	# Q: This shell script (or other program) construction is very elegant.
	#    Perhaps exploit it to the fullest?  In that case, we could,
	#    instead of the "begin"-block, say, for example.
	# =====================================================================
	run "/bin/sh" {		# Don't mind the name :)
		# A complete shell script here, invoked with the mail as stdin.
		# The script's stdout will replace the mail body.
		TARGETS=""
		for f in $HOME/* ; do
		        if [ $f != "$HOME/bart" ] && [ $f != "$HOME/maggy" ]; then
		                TARGETS=`echo "$TARGETS $f"`
		        fi
		done
		
		# Print list of all dirs in $HOME, excluding "bart" and "maggy"
		# dirs
		echo $TARGETS
	}
}
